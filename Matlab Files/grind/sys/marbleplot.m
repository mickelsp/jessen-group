%MARBLEPLOT   Calculate marble-in-a-cup potential plot (1D model)
%   In one dimensional models you can represent the stability of equilibria as
%   potential landscape with hills and valleys. The landscape can be generated by 
%   solving the potential function of the model:
%   dx/dt=f(x)
%   transform this model to the potential equation:
%   -dV/dx=f(x)
%   The simulation of this model (initial condition=0) gives the stability plot at several values of 
%   a parameter, to create a plot comparable as in Scheffer et al. 2001 
%   (Nature 413: 591-596). The current state is often represented by a marble, but one should imagine
%   that this marble is heavily damped and sliding through a greasy substance (Strogatz, 1994).
%    
%   Usage:
%   MARBLEPLOT - the user is asked to enter the required information.
%   MARBLEPLOT NPOT PAR [MINPAR,MAXPAR] VAR [MINVAR, MAXPAR] - NPOT= the number of
%   stability lines, PAR = name of control parameter; [MINPAR, MAXVAR]= range of 
%   parameter; VAR = state variable; [MINVAR MAXVAR] range of state variable.
%   MARBLEPLOT(STRUC) - structure with all settings. Fields:
%   npot: number of potentials; par: parameter to change; rangepar: range of the</br.
%   parameter; statevar: state variable; rangestatevar: range of state variable;
%   varzero: how scale the potentials; stemlength: relative length of the stems;
%   patchheight: relative height of the minimum potential; mincolor: color of the
%   last landscape; mincolor: color of the first landscape; opaqueness: opaqueness
%   (see alpha) 
%   MARBLEPLOT -o - get structure with default settings
%
%   See also potential, null, ax

%   Copyright 2012 WUR
%   Revision: 1.1.8 $ $Date: 15-Mar-2012 10:05:27 $
function res = marbleplot(npot, par, rangepar, statevar, rangestatevar,varzero, ...
   stemlength, patchheight, mincolor, maxcolor, opaqueness)
global g_grind;
showballs = 1;
%backwards=0; exchange min and max par to go backw
potdata = '';
if (nargin > 0) && ischar(npot) && strncmpi(npot, '-o', 2)
   if ~exist('g_grind','var') || isempty(g_grind)
      par = '';
      statevar = '';
   else
      par = g_grind.xaxis.var;
      iX = i_getno(par);
      if (isempty(iX) || (~iX.ispar)) && (~isempty(g_grind.pars))
         par = g_grind.pars{1};
         statevar = g_grind.xaxis.var;
      else
         statevar = g_grind.yaxis.var;
      end;
   end;
   if isfield(g_grind, 'marbleplot')
      res = struct('npot', i_checkstr(g_grind.marbleplot{1}), ...
         'par', g_grind.marbleplot{2}, ...
         'rangepar', i_checkstr(g_grind.marbleplot{3}), ...
         'statevar', g_grind.marbleplot{4}, ...
         'rangestatevar', i_checkstr(g_grind.marbleplot{5}), ...
         'varzero', g_grind.marbleplot{6}, ...
         'stemlength', i_checkstr(g_grind.marbleplot{7}), ...
         'patchheight', i_checkstr(g_grind.marbleplot{7}), ...
         'mincolor', i_checkstr(g_grind.marbleplot{8}), ...
         'maxcolor', i_checkstr(g_grind.marbleplot{9}), ...
         'opaqueness', i_checkstr(g_grind.marbleplot{10}),'potdata',[]);
      h = i_checkstr(res.varzero);
      if ~isempty(h)
         res.varzero = h;
      end;
      if length(res.stemlength) > 1
         res.stemlength = res.stemlength(1);
         res.patchheight = res.patchheight(2);
      else
         res.patchheight = 0.1;
      end;
   else
      res=struct('npot', 5,'par', par,'rangepar',g_grind.xaxis.lim,'statevar', ...
         statevar,'rangestatevar',g_grind.yaxis.lim,'varzero','minpot',...
         'stemlength',1,'patchheight',0.1,'mincolor',[0.8 0.8 0.8],...
         'maxcolor',[0.5 0.5 0.5],'opaqueness',0.9,'potdata',[]);
   end;
   return;
end;
if (nargin==1) && isstruct(npot)
   s = npot;
   npot = s.npot;
   par = s.par;
   rangepar = s.rangepar;
   statevar = s.statevar;
   rangestatevar = s.rangestatevar;
   varzero = s.varzero;
   stemlength = s.stemlength;
   patchheight = s.patchheight;
   mincolor = s.mincolor;
   maxcolor = s.maxcolor;
   opaqueness = s.opaqueness;
   potdata = s.potdata; %if you add data you need three fields here: potdata.pots, potdata,xs, potdata.pars
else
   if nargin < 6
      varzero = 'minpot';
   end;
   if nargin < 7
      stemlength = 1;
   end;
   if nargin < 8
      patchheight  = 0.1;
   end;
   if nargin < 9
      mincolor = [0.8 0.8 0.8];
   end;
   if nargin < 10
      maxcolor = [0.5 0.5 0.5];
   end;
   if nargin < 11
      opaqueness = 0.9;
   end;
   if nargin >= 5
      npot = i_checkstr(npot);
      rangepar = i_checkstr(rangepar);
      rangestatevar = i_checkstr(rangestatevar);
   else
      if nargin < 2
         par = g_grind.xaxis.var;
         iX = i_getno(par);
         if (isempty(iX) || (~iX.ispar)) && (~isempty(g_grind.pars))
            par = g_grind.pars{1};
         end;
      end;
      if nargin < 4
         statevar = g_grind.xaxis.var;
         iX = i_getno(statevar);
         if isempty(iX) || iX.ispar
            statevar = i_statevars_names(1);
         end;
      end;
      if isempty(potdata)&&(g_grind.statevars.dim > 1)
         error('GRIND:marbleplot:Dimension','This function can only work with one state variable models');
      end;
      answer={'5',par,sprintf('[%d %d]',g_grind.xaxis.lim),statevar,sprintf('[%d %d]',g_grind.yaxis.lim),'minpot'...
         sprintf('[%g %g]',stemlength,patchheight),sprintf('[%g %g %g]',mincolor),...
         sprintf('[%g %g %g]', maxcolor), num2str(opaqueness)};
      prompt={'Number of potential lines','Parameter','Range of parameter','State variable',...
         'Range of state variable','Zero relative to (minpot,minvar,maxvar,state var value)',...
         'Relative length of stems/minimum patchheight','First color (RGB)'...
         'Last color (RGB)','Opaqueness'};
      if isfield(g_grind, 'marbleplot') && ~isempty(g_grind.marbleplot)
         answer = g_grind.marbleplot;
      end;
      answer = inputdlg(prompt, 'Marble-in-a-cup plot', 1, answer);
      g_grind.marbleplot = answer;
      npot = i_checkstr(answer{1});
      par = answer{2};
      rangepar = i_checkstr(answer{3});
      statevar = answer{4};
      rangestatevar = i_checkstr(answer{5});
      varzero = answer{6};
      stemlength = i_checkstr(answer{7});
      if length(stemlength) == 2
         patchheight = stemlength(2);
         stemlength = stemlength(1);
      end;
      mincolor = i_checkstr(answer{8});
      maxcolor = i_checkstr(answer{9});
      opaqueness = i_checkstr(answer{10});
   end;
end;
pots = cell(1, npot);
xs =  cell(1, npot);
ps =  cell(1, npot);
maxpot = -9999;
minpot = 9999;
if ~isempty(potdata)
   pots = potdata.pots;
   xs = potdata.xs;
   ps = potdata.ps;
   hfig=figure;
   i_plotdefaults;
   ylabel(statevar);
   xlabel(par);
else
   oldxax = g_grind.xaxis;
   oldyax = g_grind.yaxis;
   oldzax = g_grind.zaxis;
   oldpar = evalin('base', par);
   try
      iX = i_getno(par);
      if isempty(iX) || ~iX.ispar
         error('GRIND:marbleplot:NoPar','"%s" is not a parameter',par);
      end;
      iX = i_getno(statevar);
      if isempty(iX) || ~iX.isvar
         error('GRIND:marbleplot:NoStatevar','"%s" is not a state variable',statevar);
      end;
      ax('x', par, rangepar);
      ax('y', statevar, rangestatevar);
      ax('z');
      null 100;
      legend off;
      set(get(gca,'children'),'linestyle','-','tag','nullplot')
      hold on;
      hfig = gcf;
      %get potentials    
      for i = 1:npot
         apar = rangepar(1) + (rangepar(2) - rangepar(1)) * (i - 1) / (npot - 1);
         assignin('base', par, apar);
         [x, pot] = potential;
         pots{i} = pot;
         xs{i} = x;
         ps{i} = ones(size(x)) * apar;
      end;
      g_grind.xaxis = oldxax;
      g_grind.yaxis = oldyax;
      g_grind.zaxis = oldzax;
      assignin('base', par, oldpar);
   catch err
      %   err=lasterror;
      g_grind.xaxis = oldxax;
      g_grind.yaxis = oldyax;
      g_grind.zaxis = oldzax;
      assignin('base', par, oldpar);
      rethrow(err);
   end;
end;
%analyse/scale potentials
for i = 1:npot
   pot = pots{i};
   switch varzero
    case 'minpot'
      pot = pot - min(pot) + 1;
    case 'maxpot'
      pot = pot - max(pot) + 1;
    case 'minvar'
      pot = pot - pot(1) + 1;
    case 'maxvar'
      pot = pot - pot(end) + 1;
    otherwise
      if ischar(varzero)
        vardif = abs(xs{i} - str2double(varzero));
      else
        vardif = abs(xs{i} - varzero);        
      end;
      pot=pot - pot(vardif == min(vardif)) + i;
   end;
   pots{i} = pot;
   m = max(pot);
   if m > maxpot
      maxpot = m;
   end;
   m = min(pot);
   if m < minpot
      minpot = m;
   end;
end;
%scale pots between stemlength and stemlength+1
for i = 1:npot
   pots{i} = (pots{i} - minpot) / (maxpot - minpot) + stemlength;
end;
offset = stemlength;
minpatch  = stemlength - patchheight;
hold on;
plot3([rangepar(1), rangepar(1), rangepar(2), rangepar(2)], ...
   [rangestatevar(1),rangestatevar(2),rangestatevar(2),rangestatevar(1)],[0, 0, 0, 0],'k-');
for i = npot:-1:1 % from the back to the front
   figure(hfig);
   apar = ps{i}(1);
   xx = [apar; ps{i}; apar];
   yy = [rangestatevar(1); xs{i}; rangestatevar(2)];
   zz = [minpatch; pots{i} ; minpatch];
   color = mincolor + (maxcolor - mincolor) / (npot - 1) * (i - 1);
   %     gr = 0.5 + (npot - i + 1) / 2 / (npot + 1);
   h = patch(xx, yy, zz, color);
   alpha(h, opaqueness)
   hold on;
   plot3([apar, apar, apar, apar], [rangestatevar(1), rangestatevar(1), rangestatevar(2), rangestatevar(2)], ...
      [minpatch, 0 ,0, minpatch], 'k--');
   ax1  = pots{i};
   minindex = find( diff( sign( diff([ax1(1); ax1; ax1(end)]) ) ) > 0 );
   if (~isempty(minindex)) && showballs
      plot3(apar * ones(size(minindex)), xs{i}(minindex), ax1(minindex),'o');
   end;
end;
set(gca,'DrawMode', 'fast');
set(gca, 'View', [ -68 20]);
if rangepar(1)>rangepar(2)
set(gca, 'View', [105 20]);
end;    
set(gca, 'Zlim', [0, offset + 1]);
set(gca, 'ZTick', []);
set(gca, 'ZTickLabel', [])
box off;

